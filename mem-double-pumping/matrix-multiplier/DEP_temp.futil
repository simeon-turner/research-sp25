// A 2x2 matrix mutltiplier

import "primitives/core.futil";
import "primitives/memories/seq.futil";
import "static_multiplier.futil";

component main() -> () {
  cells {
    @external(1) A0 = seq_mem_d1(32, 4, 2);
    @external(1) B0 = seq_mem_d1(32, 4, 2);
    @external(1) C0 = seq_mem_d1(32, 4, 2);

    // registers to store values
    A0_tmp_2 = std_reg(32);
    B0_tmp_2 = std_reg(32);
    C0_tmp_2 = std_reg(32);

    // for calculating the partial sum
    add32_2 = std_add(32);
    mult32_2 = iterative_multiplier();

    // for calculating the address
    add0_2 = std_add(2);
    l_shiftA_2 = std_lsh(2); // left << right
    addA_2 = std_add(2);
    l_shiftB_2 = std_lsh(2); // left << right
    addB_2 = std_add(2);
    l_shiftC_2 = std_lsh(2); // left << right
    addC_2 = std_add(2);

    // constants with  bit width 32
    const0_32 = std_const(32, 0);

    // to keep track of memory index
    // i for row of C0, j for column of C0, k for element being accumulated from A0 and B0
    i0_2 = std_reg(2);
    j0_2 = std_reg(2);
    k0_2 = std_reg(2);

    // constants with bit width 2
    const0_2 = std_const(2, 0);
    const1_2 = std_const(2, 1);
  }

  wires {
    
    add32_2.right = mult32_2.out;
    add32_2.left = C0_tmp_2.out;
    
    static<1> group init_i_2 {
      i0_2.write_en = 1'd1;
      i0_2.in = const0_2.out;
    }
    static<1> group init_j_2 {
      j0_2.write_en = 1'd1;
      j0_2.in = const0_2.out;
    }
    static<1> group init_k_2 {
      k0_2.write_en = 1'd1;
      k0_2.in = const0_2.out;
    }
    static<1> group incr_i_2 {
      i0_2.write_en = 1'd1;
      add0_2.left = i0_2.out;
      add0_2.right = const1_2.out;
      i0_2.in = add0_2.out;
    }
    static<1> group incr_j_2 {
      j0_2.write_en = 1'd1;
      add0_2.left = j0_2.out;
      add0_2.right = const1_2.out;
      j0_2.in = add0_2.out;
    }
    static<1> group incr_k_2 {
      k0_2.write_en = 1'd1;
      add0_2.left = k0_2.out;
      add0_2.right = const1_2.out;
      k0_2.in = add0_2.out;
    }

    static<1> group reset_C0_tmp_2 {
      C0_tmp_2.write_en = 1'd1;
      C0_tmp_2.in = const0_32.out;
    }
    static<1> group calc_addr_2 {
      A0.content_en = 1'd1;
      B0.content_en = 1'd1;

      l_shiftA_2.left = i0_2.out;
      l_shiftA_2.right = const1_2.out;
      addA_2.left = k0_2.out;
      addA_2.right = l_shiftA_2.out;

      l_shiftB_2.left = k0_2.out;
      l_shiftB_2.right = const1_2.out;
      addB_2.left = j0_2.out;
      addB_2.right = l_shiftB_2.out;

      A0.addr0 = addA_2.out;
      B0.addr0 = addB_2.out;
    }
    static<1> group write_tmp_regs_2 {
      A0_tmp_2.write_en = 1'd1;
      B0_tmp_2.write_en = 1'd1;
      A0_tmp_2.in = A0.read_data;
      B0_tmp_2.in = B0.read_data;
    }
    static<33> group multiply_2 {
      mult32_2.left = A0_tmp_2.out;
      mult32_2.right = B0_tmp_2.out;
      mult32_2.go = 1'd1;
    }
    static<1> group update_2 {
      C0_tmp_2.write_en = 1'd1;
      C0_tmp_2.in = add32_2.out;
    }
    static<1> group write_val_2 {
      C0.content_en = 1'd1;
      C0.write_en = 1'd1;

      l_shiftC_2.left = i0_2.out;
      l_shiftC_2.right = const1_2.out;
      addC_2.left = j0_2.out;
      addC_2.right = l_shiftA_2.out;

      C0.addr0 = addC_2.out;
      C0.write_data = C0_tmp_2.out;
    }
  }

  control {
    static seq {
      init_i_2;

      static repeat 2 { // loop over the rows
        static seq {
          init_j_2;

          static repeat 2 { // loop over the columns
            static seq {
              static par {
                init_k_2;
                reset_C0_tmp_2;
              }

              static repeat 2 { // loop over elements to accumulate
                static seq {
                  calc_addr_2;
                  write_tmp_regs_2;

                  multiply_2;
                  update_2;

                  incr_k_2;
                }
              } // end loop k

              write_val_2;
              incr_j_2;
            }
          } // end loop j

          incr_i_2;
        }
      } // end loop i
    }
  } // end control
}